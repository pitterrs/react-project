const Charts = function (H) {
    const Charts = function (e) {
        this.$element = H.logEl(e, 'Chart: ');
        Charts.colors = ["#367C2B", "#FFDE00", "#BAB994", "#333333", "#FFB000", "#E5E6E6", "#717A80", "#FFF494", "#A3AE58"];
    };

    Charts.prototype = {

        Pie: function (data, options, callback) {
            const self = this;

            var c = new Chart(self.$element, {
                type: 'pie',
                data: data,
                options: {
                    responsive: true,
                    maintainAspectRatio: false
                }
            });

            if (typeof options !== 'undefined' && options !== null) {
                options.call(c);
            }

            c.data.datasets.forEach((dataset) => {
                if (dataset.backgroundColor === undefined || dataset.backgroundColor === null) {
                    dataset.backgroundColor = Charts.colors;
                }
            });

            c.update();

            self.$chart = c;
            if (typeof callback !== 'undefined' && callback !== null) {
                callback(c);
            }
            // Legend for Pie is not loading correct colors when chart is generated since v2.9.4
            // Calling this update function again seems to fix the issue and load the colors correctly.
            // Found issue here, https://github.com/chartjs/Chart.js/issues/7457. Doesn't look
            // it will be fixed before v3.
            self.$chart.update();

            return self.$chart;
        },

        Bar: function (data, options, callback) {
            const self = this;

            var c = new Chart(self.$element, {
                type: 'bar',
                data: data,
                options: {
                    legend: {
                        display: false
                    },
                    responsive: true,
                    maintainAspectRatio: false
                }
            });

            if (typeof options !== 'undefined' && options !== null) {
                options.call(c);
            }

            c.data.datasets.forEach((dataset) => {
                if (dataset.backgroundColor === undefined || dataset.backgroundColor === null) {
                    dataset.backgroundColor = Charts.colors;
                }
            });

            c.update();

            self.$chart = c;
            if (typeof callback !== 'undefined' && callback !== null) {
                callback(c);
            }
            return self.$chart;
        },

        Line: function (data, options, callback) {
            const self = this;
            var colorIndex = 0;

            var c = new Chart(self.$element, {
                type: 'line',
                data: data,
                options: {
                    responsive: true,
                    maintainAspectRatio: false
                }
            });

            if (typeof options !== 'undefined' && options !== null) {
                options.call(c);
            }

            c.data.datasets.forEach((dataset) => {
                var incrementBrandColor = false;

                // if not specified, set a standard borderColor from our default brand colors
                if (!dataset.borderColor) {
                    dataset.borderColor = Charts.colors[colorIndex];
                    incrementBrandColor = true;
                }

                // if not specified, set a standard borderColor from our default brand colors
                if (!dataset.backgroundColor) {
                    dataset.backgroundColor = Charts.colors[colorIndex];
                    incrementBrandColor = true;
                }

                // if no fill is specified, default fill to false.
                if (!dataset.fill)
                    dataset.fill = false;

                // if we used one of the default brand colors, then increment our color index.  Loop it back to the beginning if we're on the last one.
                if (incrementBrandColor)
                    colorIndex = Charts.colors[colorIndex + 1] ? colorIndex + 1 : 0;

            });

            c.update();

            self.$chart = c;
            if (typeof callback !== 'undefined' && callback !== null) {
                callback(c);
            }
            return self.$chart;
        }

    };

    H.Charts = function (a) {
        return new Charts(H.elementOrId(a));
    };
};

module.exports = Charts;
