// Copyright (c) 2018 Deere & Company

if (!Element.prototype.matches) {
    Element.prototype.matches = function (selector) {
        if (Element.prototype.msMatchesSelector) {
            return this.msMatchesSelector(selector);
        }

        elm = this;
        let matches = (elm.document || elm.ownerDocument).querySelectorAll(selector),
            i = matches.length;

        // eslint-disable-next-line no-empty
        while (--i >= 0 && matches.item(i) !== elm) { }
        return i > -1;
    };
}

// Browser Polyfill for requestAnimationFrame
if (!window.requestAnimFrame) {
    window.requestAnimFrame = (
        function () {
            return window.requestAnimationFrame ||
                window.webkitRequestAnimationFrame ||
                window.mozRequestAnimationFrame ||

                function (callback) {
                    window.setTimeout(callback, 1000 / 60);
                };
        }());
}

Number.isInteger = Number.isInteger || function (value) {
    return typeof value === 'number' &&
        isFinite(value) &&
        Math.floor(value) === value;
};

const $UXF = (function () {
    // eslint-disable-next-line no-unused-vars
    const Helper = function (element) {
        this.Register = {};
        this.Deregister = {};
        this.componentId = 0;
        this.uxfd = 'uxfd';
    };

    Helper.prototype = {

        /*
         * This is the function that all components initially run their event
         * registration through. Right now, it just handles default registration
         * of events, but this could be expanded to handle other initial settings.
         */
        defaultRegister: function (func) {
            const self = this;

            self.addLoadEvent(function () {
                if (self.defaultBinds) {
                    func();
                }
            });
        },


        log: function (msg) {
            // eslint-disable-next-line no-console
            console.log(`%cUXF: ${msg}`, 'background: #; color: #367c2b');
        },

        logError: function (msg) {
            // eslint-disable-next-line no-console
            console.log(`%cUXF Error: ${msg}`, 'background-color:#fee; color:#900;');
        },

        logWarning: function (msg) {
            // eslint-disable-next-line no-console
            console.log(`%cUXF Warning: ${msg}`, 'background-color:#ffe; color:#f90;');
        },

        logEl: function (el, msg) {
            if (H.debug) {
                if (el) {
                    // eslint-disable-next-line no-console
                    console.log(msg + el);
                } else {
                    H.logError(`${msg}undefined`);
                }

                if (H.debugShowHTML) {
                    if (el) {
                        // eslint-disable-next-line no-console
                        console.log(`|-- HTML: ${el.outerHTML}`);
                    } else {
                        H.logError('|-- HTML: DOM element not found.');
                    }
                }
            }

            return el;
        },

        /*
         * Simply a helper function force registration of all components.
         */
        registerAll: function () {
            for (const i in this.Register) {
                this.Register[i]();
            }
        },
        /*
         * Adds an event on window.load, or runs if it is already loaded
         */
        addLoadEvent: function (func) {
            if (document.readyState === 'complete') {
                // console.log('ran');
                func();
            } else {
                const oldonload = window.onload;

                if (typeof window.onload !== 'function') {
                    window.onload = func;
                } else {
                    window.onload = function () {
                        if (oldonload) {
                            oldonload();
                        }
                        func();
                    };
                }
            }
        },

        /*
         * Helper function for adding an event to a given element.
         * In addition to standard events, the string "immediate"
         * is also valid, which will cause the event to be immediately
         * executed.
         *
         * Fourth argument allows overriding of the bound object for the event
         * this is helpful when we directly bind the object to a DOM element.
         */
        addEvent: function (element, evnt, funct, bind) {
            const thisCont = (bind === undefined) ? element : bind;

            if (evnt == 'immediate') {
                funct.call(thisCont, evnt);
            } else if (element.attachEvent) {
                // console.log('aE');
                var f = function () {
                    // We use .call() here so that the $this context is set correctly.
                    funct.call(thisCont, evnt);
                };
                const bound = element.attachEvent(`on${evnt}`, f);

                if (bound) {
                    return f;
                } else {
                    return false;
                }
            } else {
                var fn = funct.bind(thisCont);
                // console.log('aEL');

                element.addEventListener(evnt, fn, false);
                return f;
            }
        },

        removeEvent: function (element, evnt, funct) {
            if (element.detachEvent) {
                element.detachEvent(`on${evnt}`, funct);
            } else {
                // var f = funct.bind(thisCont);
                // console.log('aEL');
                element.removeEventListener(evnt, funct);
                // return f;
            }
        },

        triggerEvent: function (evntType, elmnt, eventType) {
            if (eventType == undefined) {
                eventType = 'HTMLEvents';
            }
            let evnt;

            if (document.createEvent) {
                evnt = document.createEvent(eventType);
                evnt.initEvent(evntType, true, true);
            } else {
                evnt = document.createEventObject();
                evnt.eventType = evntType;
            }

            evnt.eventName = eventType;

            if (document.createEvent) {
                elmnt.dispatchEvent(evnt);
            } else {
                elmnt.fireEvent(`on${evnt.eventType}`, evnt);
            }
        },

        stopProp: function (event) {
            if (event.stopPropagation) {
                event.stopPropagation();
            } else if (window.event) {
                window.event.cancelBubble = true;
            }
        },

        /*
         * Takes an element and a class string and returns a boolean
         * if the element has the class
         */
        hasClass: function (element, cls) {
            return element.className.match(new RegExp(`(\\s|^)${cls}(\\s|$)`));
        },

        /*
         * Checks if an element is currently visible in the viewport
         */
        isElementInViewport: function (element) {
            // special bonus for those using jQuery
            if (typeof jQuery === 'function' && element instanceof jQuery) {
                element = element[0];
            }

            const rect = element.getBoundingClientRect();

            return (
                rect.top >= 0 &&
                rect.left >= 0 &&
                rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) && /* or $(window).height() */
                rect.right <= (window.innerWidth || document.documentElement.clientWidth) /* or $(window).width() */
            );
        },
        /*
         * Checks if an element contains another element somewhere in its subtree.
         */
        containsChild: function (element, child) {
            return (element !== child && element.contains(child));
        },

        /*
         * Used to animate an element using css style properties.  Useful for browsers that don't support CSS Elements transitions,
         * and for components that aren't strucutred to take advantage of CSS Elements transitions.
         */
        animateElement: function (element, style, unit, from, to, time) {
            if (!element) {
                return;
            }
            let start = new Date().getTime(),
                timer = setInterval(function () {
                    const step = Math.min(1, (new Date().getTime() - start) / time);

                    element.style[style] = (from + step * (to - from)) + unit;
                    if (step == 1) {
                        clearInterval(timer);
                    }
                }, 25);

            element.style[style] = from + unit;
        },
        /*
         * Used to animate the scrolling of an element vertically.  Again, useful for browsers that don't support CSS Elements transitions,
         * and for components that aren't structured to take advantage of CSS Elements transitions.
         */
        scrollToY: function (pElement, pScrollTargetY, pSpeed, pEasing) {
            // scrollTargetY: the target scrollY property of the window
            // speed: time in pixels per second
            // easing: easing equation to use

            // var scrollY = window.scrollY || document.documentElement.scrollTop,
            var scrollY = pElement.scrollTop,
                element = pElement,
                scrollTargetY = pScrollTargetY,
                speed = pSpeed || 2000,
                easing = pEasing || 'easeOutSine',
                currentTime = 0;

            // min time .1, max time .8 seconds
            const time = Math.max(0.1, Math.min(Math.abs(scrollY - scrollTargetY) / speed, 0.8));

            // easing equations from https://github.com/danro/easing-js/blob/master/easing.js
            const easingEquations = {
                easeOutSine: function (pos) {
                    return Math.sin(pos * (Math.PI / 2));
                },
                easeInOutSine: function (pos) {
                    return (-0.5 * (Math.cos(Math.PI * pos) - 1));
                },
                easeInOutQuint: function (pos) {
                    if ((pos /= 0.5) < 1) {
                        return 0.5 * Math.pow(pos, 5);
                    }
                    return 0.5 * (Math.pow((pos - 2), 5) + 2);
                }
            };

            // add animation loop
            function tick() {
                currentTime += 1 / 60;

                const p = currentTime / time;
                const t = easingEquations[easing](p);

                if (p < 1) {
                    requestAnimFrame(tick);

                    // H.scrollTo(element, scrollY + ((scrollTargetY - scrollY) * t));
                    element.scrollTop = scrollY + ((scrollTargetY - scrollY) * t);
                } else {
                    //console.log('Modal scroll done.');
                    // H.scrollTo(element, scrollTargetY, 1/60);
                    element.scrollTop = scrollTargetY;
                }
            }

            // call it once to get started
            tick();
        },

        /*
         * Scrolls to an element
         */
        scrollTo: function (element, to, duration) {
            if (duration <= 0) {
                return;
            }
            const difference = to - element.scrollTop;
            const perTick = difference / duration * 10;

            setTimeout(function () {
                element.scrollTop = element.scrollTop + perTick;
                if (element.scrollTop === to) {
                    return;
                }
                H.scrollTo(element, to, duration - 10);
            }, 10);
        },

        /*
         * Removes class string from a given element.
         */
        removeClass: function (ele, cls) {
            const reg = new RegExp(`(\\s|^)${cls}(\\s|$)`);

            ele.className = ele.className.replace(reg, ' ');
        },

        /*
         * Adds class string from a given element.
         */
        addClass: function (ele, cls) {
            ele.className += ` ${cls}`;
        },

        /*
         * Toggles class string from a given element.
         */
        toggleClass: function (element, clss) {
            const self = this;

            if (self.hasClass(element, clss)) {
                self.removeClass(element, clss);
            } else {
                self.addClass(element, clss);
            }
        },

        createDiv: function (cls, content) {
            const d = document.createElement('div');

            if (cls !== undefined) {
                d.className += (` ${cls}`);
            }
            if (content !== undefined) {
                d.innerHTML = content;
            }
            return d;
        },

        /*
         * Returns the previous sibiling. This can be helpful
         * because ie8 has some werid behaviour by default.
         */
        previousElementSibling: function (el) {
            if (el.previousElementSibling) {
                return el.previousElementSibling;
            } else {
                while (el == el.previousSibling) {
                    if (el.nodeType === 1) {
                        return el;
                    }
                }
            }
        },

        /*
         * Returns the next sibiling. This can be helpful
         * because ie8 has some werid behaviour by default.
         */
        nextElementSibling: function (el) {
            if (el.nextElementSibling) {
                return el.nextElementSibling;
            } else {
                while (el == el.nextSibling) {
                    if (el.nodeType === 1) {
                        return el;
                    }
                }
            }
        },

        /*
         * Returns either the element passed in, or if the argument
         * is a string, find the element with that Id.
         * This is used because we want people to be able to
         * select elements both with a tool like JQuery and by id.
         */
        elementOrId: function (a) {
            if (typeof a === 'string' || a instanceof String) {
                return document.getElementById(a);
            } else {
                return a;
            }
        },

        registerObject: function (id, obj) {
            // console.log(arguments);
            const self = this;

            if (obj.uxfid === undefined) {
                obj.uxfid = self.componentId++;
            }
            // var ele = document.getElementById(id);
            const ele = self.elementOrId(id);

            if (ele.uxfo === undefined) {
                ele.uxfo = {};
            }
            // ele['uxfo'][obj.uxfid] = new obj(ele);
            //  var args = Array.prototype.slice.call(arguments, 1);
            const args = Array.prototype.slice.call(arguments, 2);

            args.unshift(ele);
            ele.uxfo[obj.uxfid] = obj.construct(args);
            // console.log('logging from ro:', ele, ele.DP);
        },

        uniqueEventString: function (obj, selector, evnt) {
            return `${obj.uxfid}!${selector}!${evnt}`;
        },

        customSelector: function (elementSelector, obj, masterElement) {
            const self = this;
            // var boundList = [];
            // In order to correctly not rebind a function, we assign a uxfid
            // to each obj type.

            if (obj.uxfid === undefined) {
                obj.uxfid = self.componentId++;
            }
            // We need to create an array of elements we're going to apply
            // this event to.
            let elements;
            // If the user passes one of these three objects directly, we don't
            // need to do any more work.

            if (!(elementSelector === document || elementSelector === window || elementSelector == document.documentElement)) {
                // If the user doesn't provide an element, we query the whole document.
                const selectr = masterElement ? masterElement : document;
                // We're always selecting elements inside the .jd class.

                elementSelector = `${elementSelector}`;
                elements = selectr.querySelectorAll(elementSelector);
                // If we don't return any elements, it may be that the provided
                // masterElement is what we're looking for qSA doesn't check
                // selectr, so we manually check for a match.
                elements = (elements.length == 0 && masterElement && masterElement.matches(elementSelector)) ? [masterElement] : elements;
            } else {
                // If it's document or something like that, we just put it in
                // an array so the loop works.
                elements = [elementSelector];
            }
            return elements;
        },

        /*
         * This function is pretty much the crux of the helper functions.
         * This function takes care of adding a function to certain selected element
         * on a given event.
         * Passed in are:
         *      elementSelector: a string for querySelectorAll.
         *      evnt: a JS event.
         *      obj: the JS object that can be constructed using elements from the selector.
         *      func: a string which is the name of a function in obj.
         *      masterElement: if this is passed through, only querySelect internal
         *          to this element.
         * Returns:
         *      list of elements which had an event bound to them.
         */
        registerEvents: function (elementSelector, evnt, obj, func, masterElement) {
            const self = this;

            const elements = self.customSelector(elementSelector, obj, masterElement);
            const uniq = self.uniqueEventString(obj, elementSelector, evnt);

            for (let i = 0; i < elements.length; i++) {
                // We're storing data about DOM elements in e.uxfd.
                // var uxfd = 'uxfd';
                // We also need a unique identifier for each possible component and event.
                // This assumes that the same component will not bind two of the
                // same event to the same selector.
                // var uniq = obj.uxfid + '!' + elementSelector + '!' + evnt;

                let evt = null;
                // We need to construct an element to check it's shouldBind value.
                const o = new obj(elements[i]);

                // console.log(elements[i][self.uxfd]);
                // We need to ensure we don't double bind an event.
                if (!elements[i][self.uxfd]) {
                    elements[i][self.uxfd] = {};
                }
                if (!elements[i][self.uxfd][uniq]) {
                    elements[i][self.uxfd][uniq] = {};
                }
                if (!elements[i][self.uxfd][uniq].b && (o.shouldBind === undefined || o.shouldBind())) {
                    evt = self.addEvent(elements[i], evnt, function (e) {
                        // We construct a new object. I don't think we can
                        // use 'o' from above because of scope.
                        const x = new obj(this);
                        // call the function provided, passing in the event as
                        // an argument.

                        x[func](e);
                    });
                    // console.log(uniq + ": :" + evt);
                    // boundList.push(elements[i]);
                }
                // Once a component/selector/event has bound, we don't want
                // to bind it again. If it is vitally important, this value
                // can be set to false manually.
                elements[i][self.uxfd][uniq] = {
                    'f': evt,
                    'b': true
                };
            }
            // return boundList;
        },
        deregisterEvents: function (elementSelector, evnt, obj, masterElement) {
            const self = this;

            elements = self.customSelector(elementSelector, obj, masterElement);
            const uniq = self.uniqueEventString(obj, elementSelector, evnt);

            for (let i = 0; i < elements.length; i++) {
                if (elements[i][self.uxfd][uniq].b) {
                    self.removeEvent(elements[i], evnt, elements[i][self.uxfd][uniq].f);
                    elements[i][self.uxfd][uniq].b = false;
                }
            }
        }

    };

    const H = new Helper();

    H.defaultBinds = true;
    H.debug = false;
    H.debugShowHTML = false;

    /*
     * By default all of the content of the page is hidden. Once it's loaded
     * we want the page to show.
     * We do this to avoid a flash of unstyled content.
     */
    /*H.addClass(document.documentElement, 'uxf-js-enabled');
    H.addLoadEvent(function () {
        H.addClass(document.documentElement, 'uxf-loaded');
    });*/

    return H;
}());

module.exports = $UXF;
