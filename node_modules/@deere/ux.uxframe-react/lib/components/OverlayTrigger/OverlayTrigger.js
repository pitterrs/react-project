"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OverlayTrigger = void 0;

var _react = _interopRequireDefault(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _OverlayTrigger = _interopRequireDefault(require("react-bootstrap/OverlayTrigger"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

var OverlayTrigger = function OverlayTrigger(_ref) {
  var children = _ref.children,
      props = _objectWithoutProperties(_ref, ["children"]);

  return /*#__PURE__*/_react["default"].createElement(_OverlayTrigger["default"], props, children);
};

exports.OverlayTrigger = OverlayTrigger;

var triggerType = _propTypes["default"].oneOf(["click", "hover", "focus"]);

OverlayTrigger.propTypes = {
  children: _propTypes["default"].oneOfType([_propTypes["default"].element, _propTypes["default"].func]),

  /**
   * Specify which action or actions trigger Overlay visibility
   *
   * @type {'hover' | 'click' |'focus' | Array<'hover' | 'click' |'focus'>}
   */
  trigger: _propTypes["default"].oneOfType([triggerType, _propTypes["default"].arrayOf(triggerType)]),

  /**
   * A millisecond delay amount to show and hide the Overlay once triggered
   */
  delay: _propTypes["default"].oneOfType([_propTypes["default"].number, _propTypes["default"].shape({
    show: _propTypes["default"].number,
    hide: _propTypes["default"].number
  })]),

  /**
   * The visibility of the Overlay. `show` is a _controlled_ prop so should be paired
   * with `onToggle` to avoid breaking user interactions.
   *
   * Manually toggling `show` does **not** wait for `delay` to change the visibility.
   *
   * @controllable onToggle
   */
  show: _propTypes["default"].bool,

  /**
   * The initial visibility state of the Overlay.
   */
  defaultShow: _propTypes["default"].bool,

  /**
   * A callback that fires when the user triggers a change in tooltip visibility.
   *
   * `onToggle` is called with the desired next `show`, and generally should be passed
   * back to the `show` prop. `onToggle` fires _after_ the configured `delay`
   *
   * @controllable `show`
   */
  onToggle: _propTypes["default"].func,

  /**
    The initial flip state of the Overlay.
   */
  flip: _propTypes["default"].bool,

  /**
   * An element or text to overlay next to the target.
   */
  overlay: _propTypes["default"].oneOfType([_propTypes["default"].func, _propTypes["default"].element]),

  /**
   * A Popper.js config object passed to the the underlying popper instance.
   */
  popperConfig: _propTypes["default"].object,
  // Overridden props from `<Overlay>`.

  /**
   * @private
   */
  target: _propTypes["default"].oneOf([null]),

  /**
   * @private
   */
  onHide: _propTypes["default"].oneOf([null]),

  /**
   * The placement of the Overlay in relation to it's `target`.
   */
  placement: _propTypes["default"].oneOf(["auto-start", "auto", "auto-end", "top-start", "top", "top-end", "right-start", "right", "right-end", "bottom-end", "bottom", "bottom-start", "left-end", "left", "left-start"])
};